
## ng-app
> 
- 标示应用root element,用于自动引导应用
- 只会识别第一个标识，如果一个页面有多个应用，必须使用手动引导 angular.bootstrap，且应用之间不能嵌套
- g-strict-di设置在根应用上，注入器将在strict-di模式下产生，意味着，自动函数注解将产生错误。
```
angular.module('ngAppStrictDemo', [])                                                            
  // 因为控制器依赖自动注解，欧意会实例化失败                                                        
  .controller('BadController', function($scope) {                                                
    $scope.a = 1;                                                                                
    $scope.b = 2;                                                                                
  })                                                                                             
  // 不像BadController, GoodController和GoodController2不会实例化失败, 
  // 因为使用数组形式和$inject属性,明确了注解 
  .controller('GoodController1', ['$scope', function($scope) {                                   
    $scope.a = 1;                                                                                
    $scope.b = 2;                                                                                
  }])                                                                                            
  .controller('GoodController2', GoodController2);                                               
  function GoodController2($scope) {                                                             
    $scope.name = "World";                                                                       
  }                                                                                              
  GoodController2.$inject = ['$scope'];                                                          
```

## angular.bootstrap(element, modules, config)
>
config现在只有一个配置项可用`strictDi`，用于是否禁用自动注解，便于发现bug
返回：auto.$injector 给该应用

```html                                                       
<!doctype html>                                               
<html>                                                        
<body>                                                        
<div ng-controller="WelcomeController">                       
  {{greeting}}                                                
</div>                                                        
                                                              
<script src="angular.js"></script>                            
<script>                                                      
  var app = angular.module('demo', [])                        
  .controller('WelcomeController', function($scope) {         
      $scope.greeting = 'Welcome!';                           
  });                                                         
  angular.bootstrap(document, ['demo']);                      
</script>                                                     
</body>                                                       
</html>                                                       
```                   
                                        
## 注解 annotation     
> js没有注解，注解是来自spring的概念，因为没有用过spring,所以也无法想通过它帮助理解。暂时理解为，注入解释.

> **有以下三种函数注解方式：**

```js                                                     
  // inferred (only works if code not minified/obfuscated)
  $injector.invoke(function(serviceA){});                 
                                                          
  // annotated                                            
  function explicit(serviceA) {};                         
  explicit.$inject = ['serviceA'];                        
  $injector.invoke(explicit);                             
                                                          
  // inline                                               
  $injector.invoke(['serviceA', function(serviceA){}]);   
```                                                       

### Inference 推论
> js中通过对函数调用toString()可以返回函数对定义，并可以提取到参数。但注入器在严格模式是不允许的。
  当压缩和混淆代码的时候，参数也会被压缩改变。

### $inject 注解
> 可以通过在函数上添加$inject属性，指定注入参数          

### inline
> 使用注入参数数组，数组的最后一项是调用函数 

### 注入器实例方法
－ get(serviceName, caller) 对应内部getService(),返回一个服务的实例。serviceName服务名；caller提供一个供错误消息的调用
－ invoke(fn, self, locals, serviceName) 调用该方法，并应用从$injector取得的方法参数。 fn调用的方法；self:fn的this; locals:可选对象，如果存在，首先从对象取参数
－ has(name) 查询服务是否存在。
－ instantiate(Type, locals, serviceName) 实例化一个js类型，需要一个构造函数，使用new调用，并应用构造函数指定的注解参数。Type：一个构造函数；locals:可选，如果传入，优先从其上读取参数。
－ annotate(fn, strictDi, names) 与createInjector.$$annotate指向同个函数。被注射器使用，当函数调用的时候，用于判断哪些服务将被注入。返回服务名数组。
         
         
         
         
         
         
         
         
         
         
         